{"version":3,"file":"abstract-geocoder.js","sourceRoot":"","sources":["../../../src/geocoder/abstract-geocoder.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,8BAA8B,EAAE,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAE,aAAa,EAAE,MAAM,WAAW,CAAC;AAC1C,OAAO,EAAE,qBAAqB,EAAE,oBAAoB,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAKxF,MAAM,OAAgB,gBAAiB,SAAQ,eAAe,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAOvE,KAAK,CAAC,iBAAiB,CAAC,QAA0B,EAAE,KAA4B;QACtF,OAAO,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAES,KAAK,CAAC,iBAAiB,CAAC,QAA0B,EAAE,KAA4B;QACtF,OAAO,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAES,KAAK,CAAC,iBAAiB,CAAC,QAA0B,EAAE,KAA4B;QACtF,OAAO,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAES,KAAK,CAAC,kBAAkB,CAAC,QAA0B,EAAE,KAA6B;QACxF,OAAO,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,KAAK,CAAiD,aAA+C;QACjG,IAAI,iBAAyB,CAAC;QAE9B,IAAI,OAAO,aAAa,KAAK,UAAU,EAAE;YACrC,IAAI,CAAC,CAAC,aAAa,CAAC,SAAS,YAAY,oBAAoB,CAAC,EAAE;gBAC5D,MAAM,8BAA8B,CAAC,8BAA8B,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;aAC3F;YAED,iBAAiB,GAAG,aAAa,CAAC,IAAI,CAAC;SAC1C;aAAM;YACH,iBAAiB,GAAG,aAAa,CAAC;SACrC;QAED,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,YAAY,EAAE,EAAE;YACxC,MAAM,aAAa,GAAqC,IAAI,CAAC,yBAAyB,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;YAEpH,IAAI,aAAa,EAAE;gBACf,OAAO,aAAa,CAAC;aACxB;SACJ;QAED,MAAM,8BAA8B,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;IACxF,CAAC;IAEO,yBAAyB,CAAC,iBAAyB,EAAE,QAA0B;QACnF,IAAI,QAAQ,YAAY,oBAAoB,IAAI,iBAAiB,KAAK,QAAQ,CAAC,WAAW,CAAC,IAAI,EAAE;YAC7F,OAAO,QAAQ,CAAC;SACnB;QAED,IAAI,QAAQ,YAAY,qBAAqB,EAAE;YAC3C,KAAK,MAAM,gBAAgB,IAAI,QAAQ,CAAC,YAAY,EAAE,EAAE;gBACpD,MAAM,aAAa,GAAqC,IAAI,CAAC,yBAAyB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;gBAC5H,IAAI,aAAa,EAAE;oBACf,OAAO,aAAa,CAAC;iBACxB;aACJ;YAED,OAAO;SACV;IACL,CAAC;CACJ","sourcesContent":["import { ProviderNotRegisteredException } from '../exception';\nimport { LoggableMixin } from '../logger';\nimport { AbstractChainProvider, AbstractHttpProvider, ProvidableMixin } from '../model';\nimport type { DistanceQueryInterface, GeocodeQueryInterface, GeocoderInterface, ReverseQueryInterface, SuggestQueryInterface } from '../interface';\nimport type { AbstractProvider, Distance, Location, Suggestion } from '../model';\nimport type { Type } from '../types';\n\nexport abstract class AbstractGeocoder extends ProvidableMixin(LoggableMixin(Object)) implements GeocoderInterface {\n    abstract geocode(query: GeocodeQueryInterface): Promise<Location[]>;\n\n    abstract reverse(query: ReverseQueryInterface): Promise<Location[]>;\n\n    abstract suggest(query: SuggestQueryInterface): Promise<Suggestion[]>;\n\n    protected async geocodeByProvider(provider: AbstractProvider, query: GeocodeQueryInterface): Promise<Location[]> {\n        return provider.geocode(query);\n    }\n\n    protected async reverseByProvider(provider: AbstractProvider, query: ReverseQueryInterface): Promise<Location[]> {\n        return provider.reverse(query);\n    }\n\n    protected async suggestByProvider(provider: AbstractProvider, query: SuggestQueryInterface): Promise<Suggestion[]> {\n        return provider.suggest(query);\n    }\n\n    protected async distanceByProvider(provider: AbstractProvider, query: DistanceQueryInterface): Promise<Distance> {\n        return provider.distance(query);\n    }\n\n    using<HttpProviderClass extends AbstractHttpProvider>(providerClass: Type<HttpProviderClass> | string): AbstractHttpProvider {\n        let providerClassName: string;\n\n        if (typeof providerClass === 'function') {\n            if (!(providerClass.prototype instanceof AbstractHttpProvider)) {\n                throw ProviderNotRegisteredException.doesNotInheritAbstractProvider(providerClass.name);\n            }\n\n            providerClassName = providerClass.name;\n        } else {\n            providerClassName = providerClass;\n        }\n\n        for (const provider of this.getProviders()) {\n            const foundProvider: AbstractHttpProvider | undefined = this.findHttpProviderRecursive(providerClassName, provider);\n\n            if (foundProvider) {\n                return foundProvider;\n            }\n        }\n\n        throw ProviderNotRegisteredException.create(providerClassName, this.getProviders());\n    }\n\n    private findHttpProviderRecursive(providerClassName: string, provider: AbstractProvider): AbstractHttpProvider | undefined {\n        if (provider instanceof AbstractHttpProvider && providerClassName === provider.constructor.name) {\n            return provider;\n        }\n\n        if (provider instanceof AbstractChainProvider) {\n            for (const internalProvider of provider.getProviders()) {\n                const foundProvider: AbstractHttpProvider | undefined = this.findHttpProviderRecursive(providerClassName, internalProvider);\n                if (foundProvider) {\n                    return foundProvider;\n                }\n            }\n\n            return;\n        }\n    }\n}\n"]}