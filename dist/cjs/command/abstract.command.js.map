{"version":3,"file":"abstract.command.js","sourceRoot":"","sources":["../../../src/command/abstract.command.ts"],"names":[],"mappings":"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","sourcesContent":["import { plainToInstance } from 'class-transformer';\nimport { validateOrReject } from 'class-validator';\nimport isEmpty from 'lodash.isempty';\nimport type { AxiosInstance, AxiosResponse } from 'axios';\nimport {\n    InvalidCredentialsException,\n    InvalidServerResponseException,\n    QuotaExceededException,\n    UnsupportedAccuracyException,\n    ValidationException,\n} from '../exception';\nimport { LoggableMixin } from '../logger';\nimport { getAvailableAccuracies } from '../util';\nimport type { QueryInterface } from '../interface';\nimport type { LoggableInterface } from '../logger';\nimport type { AccuracyEnum } from '../model';\nimport type { AbstractTransformer } from '../transformer';\nimport type { Type } from '../types';\n\nexport abstract class AbstractCommand<\n    GeocoderQueryType extends QueryInterface = any,\n    GeocoderResponseType = any,\n    GeocoderTransformerType extends AbstractTransformer = any,\n    ProviderRequestType = any,\n    ProviderResponseType = any,\n> extends LoggableMixin(Function) {\n    ['constructor']: Pick<typeof AbstractCommand, keyof typeof AbstractCommand> & { name: string } & LoggableInterface;\n\n    constructor(protected readonly httpClient: AxiosInstance, ..._args: unknown[]) {\n        super();\n    }\n\n    static queryClass(): Type<any> {\n        throw new Error('AbstractCommand.queryClass: not implemented');\n    }\n\n    /**\n     * @example If the provider doesn't provide separate information about house number, then AccuracyEnum.STREET_NAME should be set.\n     * @important This information will be used to ignore the provider if query.accuracy is specified.\n     */\n    static getMaxAccuracy(): AccuracyEnum {\n        throw new Error('AbstractCommand.getMaxAccuracy: not implemented');\n    }\n\n    static getUrl(): string {\n        throw new Error('AbstractCommand.getUrl: not implemented');\n    }\n\n    protected async buildQuery(_query: GeocoderQueryType): Promise<ProviderRequestType> {\n        throw new Error('AbstractCommand.buildQuery: not implemented');\n    }\n\n    /**\n     * Must return void or throw one of GeocoderException\n     * @throws {GeocoderException}\n     */\n    protected async validateResponse(_response: AxiosResponse<ProviderResponseType>): Promise<void> {\n        throw new Error('AbstractCommand.validateResponse: not implemented');\n    }\n\n    protected async parseResponse(_response: AxiosResponse<ProviderResponseType>, _query: GeocoderQueryType): Promise<GeocoderTransformerType[]> {\n        throw new Error('AbstractCommand.parseResponse: not implemented');\n    }\n\n    static isProvidesAccuracy(accuracy: AccuracyEnum): boolean {\n        return getAvailableAccuracies(this.getMaxAccuracy()).includes(accuracy);\n    }\n\n    async execute(_query: GeocoderQueryType): Promise<GeocoderResponseType[]> {\n        const query: GeocoderQueryType = plainToInstance<GeocoderQueryType, GeocoderQueryType>(this.constructor.queryClass(), _query);\n\n        try {\n            await validateOrReject(query, {\n                whitelist: true,\n                forbidNonWhitelisted: true,\n                validationError: { target: false, value: false },\n            });\n        } catch (err: any) {\n            this.getLogger().error(err, query);\n\n            throw new ValidationException(err);\n        }\n\n        if (query.accuracy && !this.constructor.isProvidesAccuracy(query.accuracy)) {\n            throw new UnsupportedAccuracyException(\n                `Command ${this.constructor.name} doesn't support \"${query.accuracy}\" accuracy (max accuracy is \"${this.constructor.getMaxAccuracy()}\")`,\n            );\n        }\n\n        const params: ProviderRequestType = await this.buildQuery(query);\n        let response: AxiosResponse<ProviderResponseType>;\n\n        try {\n            response = await this.getResponse(params);\n        } catch (err: any) {\n            if (err.response && err.response.status) {\n                const statusCode: number = err.response.status;\n\n                if (statusCode === 401 || statusCode === 403) {\n                    throw new InvalidCredentialsException(`API key is invalid`, err.response);\n                } else if (statusCode === 429) {\n                    throw new QuotaExceededException('Quota exceeded', err.response);\n                }\n\n                throw new InvalidServerResponseException('Server error', err.response);\n            } else {\n                throw new InvalidServerResponseException(err.message);\n            }\n        }\n\n        if (isEmpty(response.data)) {\n            throw new InvalidServerResponseException('Empty response data', response);\n        }\n\n        await this.validateResponse(response);\n\n        const transformers: GeocoderTransformerType[] = await this.parseResponse(response, query);\n\n        return Promise.all<GeocoderResponseType>(\n            transformers.map(async (transformer: GeocoderTransformerType): Promise<GeocoderResponseType> => {\n                return transformer.transform({\n                    groups: query.withRaw ? ['raw'] : undefined,\n                });\n            }),\n        );\n    }\n\n    protected async getResponse(params: ProviderRequestType): Promise<AxiosResponse<ProviderResponseType>> {\n        return this.httpClient.get<ProviderResponseType>(this.constructor.getUrl(), {\n            params,\n        });\n    }\n}\n"]}